# 2장 문자열 계산기 구현을 통한 테스트와 리펙터링

## 목차
    
1. [개념 살펴보기](#학습목표)

2. [실습 - 문자열 계산기](#실습---문자열-계산기)


## 학습목표
- 테스트와 리펙토링 이해하기
    - Main() 메소드의 문제점
    - JUnit을 사용하는 이유

### Main() 메소드를 활용한 테스트의 문제점
- 프로덕션 코드와 테스트 코드(main() 메소드)가 같은 클래스에 위치하고 있다.
    - 테스트 코드의 경우, 테스트 단계에서만 필요하기 때문에 굳이 함께 배포할 필요가 없다.
    - 이를 해결하기 위해서 프로덕션 코드와 테스트 코드를 분리하면 된다 !

그럼 이제 각각의 코드를 분리 했으니 완벽해진건가?
> 아니다..
- 별도의 클래스를 분리하긴 했지만 하나의 프로덕션 코드에 모든 메소드를 테스트하게 된다는 단점이 있다.
    - 프로덕션 코드가 복잡도가 증가할수록, Main() 메소드의 복잡도도 증가하게 된다. 
    - 이를 해결하기 위해서는 테스트 코드를 각 메소드별로 분리하면 된다.

- 각 메소드 별로 구분이 되긴 했지만, 이는 하나의 메소드를 집중해서 테스트하는데에는 어려움이 있다.
    - 우선 main() 메소드를 활용하기 때문에 해당 클래스의 모든 메소드를 다함께 테스트를 해야한다는 단점이 존재한다.
    - 콘솔에 출력되는 값을 직접 확인해야한다는 단점이 존재한다.
        - 만약, 계산의 복잡도가 증가할 경우 이후 유지보수 시에 결과 값을 머리로 계산하여 결과값이 정상적으로 출력되는지 확인해야한다.
    - 이를 해결하기 위해서 사용하는 것이 바로 `JUnit` 이다 !


### JUnit
- 단위 테스트 프레임워크 중 하나로, main() 메소드의 한계를 해결해줄 수 있는 도구이다.
- JUnit을 사용하게 되면 우선 내가 관심을 갖고 있는 메소드에 대한 테스트만 하는 것이 가능해진다.
- 또한 로직을 실행한 후 결과값 확인을 프로그래밍을 통해 자동화가 가능해진다.

### JUnit 적용해보기 !
- `@Test` 어노테이션을 추가한다.
- 이외에도 앞에서 결과값 확인이 자동화가 가능해진다고 설명했었다.
    - `assertEquals()` 메소드를 사용하여 적용할 수 있다.
    - 이 메소드 뿐만 아니라 다양한 메소드를 더 지원하고 있다.
        - `assertTrue()`, `assertFalse()` : 결과 값의 true/false 확인
        - `assertNull()`, `assertNotNull()` : 결과 값의 null 유무 확인
        - `assertArrayEquals()` : 배열 값이 같은지 검증
        > 이외에도 다른 메소드를 제공하고 있다. <br>
        > [Assert 클래스 Javadoc 문서](https://www.javadoc.io/doc/org.testng/testng/6.11/org/testng/Assert.html#method.summary)


```java
package org.example;

import org.junit.jupiter.api.Test;


class CalculatorTest {

    @Test
    void sum() {
        Calculator cal = new Calculator();
        assertEquals(3, cal.sum(1, 2));
    }

    @Test
    void sub() {
        Calculator cal = new Calculator();
        assertEquals(4, cal.sub(6,2));
    }

    @Test
    void mul() {
        Calculator cal = new Calculator();
        assertEquals(12, cal.mul(3,4));
    }

    @Test
    void div() {
        Calculator cal = new Calculator();
        assertEquals(6, cal.div(18, 3));
    }
}
```

#### 테스트 코드 중복 제거
- 테스트 코드 또한 중복 코드를 제거하는 것이 개발자가 가장 가져야할 좋은 습관 중 하나로 볼 수 있다.
- 테스트 과정에서 객체를 초기화하는 경우가 많이 생기는데 이때, 필드로써 주입하는 방식보다는 @Before 어노테이션을 활용하는 것을 추천한다.
- 이를 통해 인스턴스 상태 값이 변경되어 다음 테스트에 영향을 주는 일도 적어질 수 있다.
- 또한 @RunWith, @Rule과 같은 어노테이션을 사용하여 기능을 확장할 경우, @Before 안이어야만 초기화된 객체에 접근할 수 있도록 제약사항이 있기 때문에 사용하는 것을 권장한다.
- 이외에도 메소드 실행이 끝난 후 후처리 작업을 담당하는 @After 어노테이션도 제공하고 있다.


이를 적용하여 수정한 테스트 코드는 다음과 같다.


```java
package org.example;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    private Calculator cal;

    @BeforeEach
    public void before() throws Exception {
        cal = new Calculator();
    }

    @Test
    void sum() {
        assertEquals(3, cal.sum(1, 2));
    }

    @Test
    void sub() {
        assertEquals(4, cal.sub(6,2));
    }

    @Test
    void mul() {
        assertEquals(12, cal.mul(3,4));
    }

    @Test
    void div() {
        assertEquals(6, cal.div(18, 3));
    }
}
```



# 실습 - 문자열 계산기

## 요구사항
 
- 전달하는 문자를 구분자로 분리한 후 각 숫자의 합을 구해 반환해야 한다.
    - 쉼표(,), 콜론(:)을 구분자로 가지는 문자열을 전달하는 경우 구분자를 기준으로 분리한 각 숫자의 합을 반환한다.
        - 실행 결과 예시는 다음과 같다
            ```
            " " -> 0, "1,2" -> 3, "1,2,3" -> 6, "1,2:3" -> 6
            ```
    - 앞의 기본 구분자(쉼표, 콜론) 외에 커스텀 구분자를 지정할 수 있다.
        - 커스텀 구분자는 '//'와 '\n' 사이에 위치하는 문자를 커스텀 구분자로 사용한다.
        - 사용법은 다음과 같다
            ```
            "//;\n1;2;3"
            -> 커스텀 구분자는 세미콜론(;)이며, 결과 값은 6이 반환
            ```
        - 커스텀 구분자를 지정할 경우, 커스텀 구분자에 해당하는 숫자만 구별(기본 구분자는 처리 안됨)

    - 문자열 계산기에 음수를 전달하는 경우 RuntimeException으로 예외 처리해야 한다.


## 설계

### 구현할 것들
- [ ] 문자열에 커스텀 구분자가 있는가?
- [ ] 커스텀 구분자 단위로 문자열 쪼개기
- [ ] 구분자 단위로 추출된 문자열 숫자 저장
- [ ] 문자열을 숫자로 변환하기
- [ ] 숫자 계산하기
    - 2개 이상 계산 될 수 있음.
- [ ] 결과 반환하기
- [ ] 빈 문자열 처리 -> 0으로 처리해야함

**예외 처리**
- [ ] 문자열로 입력하지 않은 경우
- [ ] 커스텀 구분자나 기본 구분자로 입력되지 않은 경우
- [ ] 숫자가 아닌 다른 문자로 입력한 경우

### 테스트에 집중하여 설계해보자!
```markdown
요구사항을 더 작은 단위로 나눠 테스트할 경우의 수 분리하기!

구현을 시작하기 전에 **작은 단위로 나누는 연습을 하는 것**이 개발자 역량을 키우기 좋은 연습이다!!
```

#### 입력 테스트
- [x] 입력값이 빈 문자열일 경우
    - null, "", " "
- [x] 입력값이 숫자하나만 입력된 경우
    - "1", "12"...
- 입력값이 숫자가 아닌 문자와 함께 입력된 경우
    - [x] "," 구분자를 통해 입력한 경우
    - [x] ","또는 ":" 구분자를 통해 입력한 경우
    - [x] "//"과 "\n" 사이에 구분자를 넣어 커스텀한 경우

#### 예외 처리
- [ ] 구분자를 기준으로 숫자가 아닌 다른 문자를 입력한 경우 예외처리
    - "i,j,2", "#,3,4"
- [ ] 커스텀 구분자 지정을 잘못 지정하여 입력한 경우 예외 처리
    - "::i\n1i2i3"
- [ ] 기본 구분자가 아닌 다른 구분자를 커스텀 지정 없이 입력한 경우 예외처리
    - "1.2.3","1@3^4"
- [ ] 기본 구분자 이외에 다른 구분자를 혼합하여 입력한 경우 예외처리
    - "1,2\*3", "2:3,4\*5"
- [ ] 구분자 사이에 공백 넣어 입력한 경우 예외처리
    - "1, 2, 3", "1 , 2 , 3"
- [ ] 음수를 입력한 경우 예외처리


